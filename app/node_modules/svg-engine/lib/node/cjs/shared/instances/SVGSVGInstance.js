"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SVGSVGInstance = void 0;
const SVGInstance_js_1 = require("../../node/instance/SVGInstance.js");
//-- Mixins
const index_js_1 = require("../mixins/index.js");
// Permitted content
const shapeInstances_js_1 = require("../mixins/permitted-content/shapeInstances.js");
const structuralInstances_js_1 = require("../mixins/permitted-content/structuralInstances.js");
const descriptiveInstances_js_1 = require("../mixins/permitted-content/descriptiveInstances.js");
const SVGGroupInstance_js_1 = require("./SVGGroupInstance.js");
// Presentation attributes
const color_js_1 = require("../mixins/presentation-attributes/color.js");
const display_js_1 = require("../mixins/presentation-attributes/display.js");
const fill_js_1 = require("../mixins/presentation-attributes/fill.js");
const opacity_js_1 = require("../mixins/presentation-attributes/opacity.js");
const stroke_js_1 = require("../mixins/presentation-attributes/stroke.js");
const vectorEffect_js_1 = require("../mixins/presentation-attributes/vectorEffect.js");
const visibility_js_1 = require("../mixins/presentation-attributes/visibility.js");
// Attributes
const preserveAspectRatio_js_1 = require("../mixins/attributes/preserveAspectRatio.js");
const xyPositioning_js_1 = require("../mixins/attributes/xyPositioning.js");
const widthHeight_js_1 = require("../mixins/attributes/widthHeight.js");
//-- Class
class SVGSVGInstance extends SVGInstance_js_1.SVGInstance {
    constructor(widthOrParent, height, _parent) {
        // const parent = widthOrParent instanceof SVGInstance ? widthOrParent : _parent;
        super("svg");
        if (typeof widthOrParent === "string" || typeof widthOrParent === "number") {
            this.width(widthOrParent);
        }
        if (typeof height === "string" || typeof height === "number") {
            this.height(height);
        }
    }
    addGroup() {
        const group = new SVGGroupInstance_js_1.SVGGroupInstance(this);
        this.appendInstance(group);
        return group;
    }
    addSVG(width, height) {
        if (typeof width !== "undefined" && typeof height !== "undefined") {
            const svg = new SVGSVGInstance(width, height);
            this.appendInstance(svg);
            return svg;
        }
        else {
            const svg = new SVGSVGInstance();
            this.appendInstance(svg);
            return svg;
        }
    }
    viewBox(x, y, width, height) {
        if (typeof x === "undefined") {
            const viewBox = this.attr("viewBox");
            if (typeof viewBox === "string") {
                const [x, y, width, height] = viewBox.split(" ");
                return {
                    x: isNaN(+x) ? x : +x,
                    y: isNaN(+y) ? y : +y,
                    width: isNaN(+width) ? width : +width,
                    height: isNaN(+height) ? height : +height
                };
            }
            return null;
        }
        else if ((typeof x === "string" || typeof x === "number") &&
            (typeof y === "string" || typeof y === "number") &&
            (typeof width === "string" || typeof width === "number") &&
            (typeof height === "string" || typeof height === "number")) {
            this.attr("viewBox", `${x} ${y} ${width} ${height}`);
            return this;
        }
        return null;
    }
}
exports.SVGSVGInstance = SVGSVGInstance;
(0, index_js_1.applyMixins)(SVGSVGInstance, [
    shapeInstances_js_1.ShapeInstances,
    structuralInstances_js_1.StructuralInstances,
    descriptiveInstances_js_1.DescriptiveInstances,
    color_js_1.Color,
    display_js_1.Display,
    fill_js_1.Fill,
    opacity_js_1.Opacity,
    stroke_js_1.Stroke,
    vectorEffect_js_1.VectorEffect,
    visibility_js_1.Visibility,
    preserveAspectRatio_js_1.PreserveAspectRatio,
    xyPositioning_js_1.XYPositioning,
    widthHeight_js_1.WidthHeight
]);
//# sourceMappingURL=SVGSVGInstance.js.map