"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stroke = void 0;
const SVGInstance_js_1 = require("../../../browser/instance/SVGInstance.js");
class Stroke extends SVGInstance_js_1.SVGInstance {
    stroke(width = 1, style = "solid", color = "currentColor") {
        this.strokeWidth(width);
        this.strokeColor(color);
        if (style === "dashed") {
            this.strokeDasharray(3);
        }
        return this;
    }
    strokeColor(color) {
        if (typeof color === "undefined") {
            const color = this.attr("stroke");
            return typeof color === "string" ? color : null;
        }
        else if (typeof color === "string") {
            this.attr("stroke", color);
            return this;
        }
        return null;
    }
    strokeLinearGradient(gradient, rotation) {
        var _a, _b, _c;
        const defs = (_b = (_a = this.root) === null || _a === void 0 ? void 0 : _a.childInstances.find(instance => instance.element.tagName === "defs")) !== null && _b !== void 0 ? _b : (_c = this.root) === null || _c === void 0 ? void 0 : _c.addDefs();
        const linearGradient = defs === null || defs === void 0 ? void 0 : defs.addLinearGradient();
        const id = defs.element.childNodes.length;
        linearGradient.attr("id", "gradient-" + id);
        if (typeof rotation === "number") {
            linearGradient.attr("gradientTransform", "rotate(" + rotation + ")");
        }
        for (const stop of gradient) {
            linearGradient.addStop(stop.position, stop.color);
        }
        this.attr("stroke", "url(#gradient-" + id + ")");
        return this;
    }
    dash(dash = 3, color = "currentColor") {
        this.strokeDasharray(dash);
        this.strokeColor(color);
        return this;
    }
    strokeDasharray(dashGapArrayOrUndefined, gap) {
        if (typeof dashGapArrayOrUndefined === "undefined") {
            const dashGapString = this.attr("stroke-dasharray");
            if (typeof dashGapString === "number") {
                return dashGapString;
            }
            else if (typeof dashGapString === "string") {
                const dashGapArray = dashGapString.split(" ");
                if (dashGapArray.length === 1) {
                    return isNaN(+dashGapArray[0]) ? dashGapArray[0] : +dashGapArray[0];
                }
                else {
                    return dashGapArray.map(value => isNaN(+value) ? value : +value);
                }
            }
        }
        else if (typeof dashGapArrayOrUndefined === "string" || typeof dashGapArrayOrUndefined === "number") {
            this.attr("stroke-dasharray", dashGapArrayOrUndefined);
            return this;
        }
        else if (Array.isArray(dashGapArrayOrUndefined)) {
            this.attr("stroke-dasharray", dashGapArrayOrUndefined.join(" "));
            return this;
        }
        return null;
    }
    strokeDashoffset(offset) {
        if (typeof offset === "string" || typeof offset === "number") {
            this.attr("stroke-dashoffset", offset);
            return this;
        }
        return this.attr("stroke-dashoffset");
    }
    strokeLinecap(cap) {
        if (typeof cap === "undefined") {
            const cap = this.attr("stroke-linecap");
            return typeof cap === "string" ? cap : null;
        }
        else if (typeof cap === "string") {
            this.attr("stroke-linecap", cap);
            return this;
        }
        return null;
    }
    strokeLinejoin(join) {
        if (typeof join === "undefined") {
            const join = this.attr("stroke-linejoin");
            return typeof join === "string" ? join : null;
        }
        else if (typeof join === "string") {
            this.attr("stroke-linejoin", join);
            return this;
        }
        return null;
    }
    strokeMiterlimit(limit) {
        if (typeof limit === "undefined") {
            const limit = this.attr("stroke-miterlimit");
            return typeof limit === "number" ? limit : null;
        }
        else if (typeof limit === "number") {
            this.attr("stroke-miterlimit", limit);
            return this;
        }
        return null;
    }
    strokeOpacity(opacity) {
        if (typeof opacity === "string" || typeof opacity === "number") {
            this.attr("stroke-opacity", opacity);
            return this;
        }
        return this.attr("stroke-opacity");
    }
    strokeWidth(width) {
        if (typeof width === "string" || typeof width === "number") {
            this.attr("stroke-width", width);
            return this;
        }
        return this.attr("stroke-width");
    }
}
exports.Stroke = Stroke;
//# sourceMappingURL=stroke.js.map